<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>99 Balls</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&display=swap" rel="stylesheet">

<style>
html, body {
    margin: 0;
    padding: 0;
    background: #222;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

canvas {
    background: #333;
    border-radius: 12px;
}
</style>
</head>

<body>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 450;
canvas.height = 800;

// --- Constants ---
const BALL_RADIUS = 12;
const SHOOT_SPEED = 10;
const VERTICAL_GAP = 10;

const EXPLODE_BALL_RADIUS = BALL_RADIUS * 1.5;
const EXPLODE_BALL_COLOR = '#8B0000';
const EXPLODE_PICKUP = -2;
const MAX_SPLITS = 15;
const MIN_SPLITS = 7;

const PICKAXE_PICKUP = -3;

const PICKAXE_MIN_TARGETS = 6;
const PICKAXE_MAX_TARGETS = 20;
const PICKAXE_MIN_HITS = 1;
const PICKAXE_MAX_HITS = 50;

// --- Game State ---
let gameTime = 0;
let isGameOver = false;

function gameOver() {
    isGameOver = true;
}

let ballCount = 1;
let projectiles = [];
let isShooting = false;
let isLaunchSequenceComplete = false;
let ballsLaunched = 0;

let currentBaseY = canvas.height - 50;
let launchY = currentBaseY - BALL_RADIUS * 2;
let landingX = canvas.width / 2;
let currentBaseX = landingX;
let firstBallLanded = false;

let isAiming = false;
let aim_vx = 0;
let aim_vy = 0;

// --- Block Constants ---
const BLOCK_RADIUS = 28;
const BLOCK_DIAMETER = BLOCK_RADIUS * 2;
const BLOCK_ROW_TOTAL_HEIGHT = BLOCK_DIAMETER + VERTICAL_GAP;
const BLOCKS_PER_ROW = 7;

let currentLevel = 1;
let numberedBlocks = [];
let particles = [];
let nowBreaked = 0;

// --- Title ---
let activeTitles = [];

function showTitle(text, color = "red") {
    activeTitles.push({
        text,
        color,
        life: 0,
        maxLife: 120,
        fadeInDuration: 30,
        fadeOutDuration: 30
    });
}

/* =====================
   Particle / Projectile
   ===================== */

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3 + 1;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 100;
    }
    update() {
        this.vy += 0.1;
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = this.life / 100;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Projectile {
    constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = BALL_RADIUS;
        this.isFinished = false;
    }

    update() {
        this.vy += 0.0025;
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < this.radius || this.x > canvas.width - this.radius) {
            this.vx *= -1;
        }
        if (this.y < this.radius) {
            this.vy *= -1;
        }

        this.checkBlocks();

        if (this.y > currentBaseY) {
            if (!firstBallLanded) {
                landingX = this.x;
                firstBallLanded = true;
            }
            this.isFinished = true;
        }
    }

    checkBlocks() {
        numberedBlocks.forEach(b => {
            if (!b.isAlive) return;
            const dx = this.x - b.x;
            const dy = this.y - b.y;
            if (dx * dx + dy * dy < (this.radius + b.radius) ** 2) {
                b.hit();
                this.vx *= -1;
                this.vy *= -1;
            }
        });
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = '#F2DC38';
        ctx.lineWidth = 4;
        ctx.stroke();
    }
}

/* =====================
   Block
   ===================== */

class Block {
    constructor(x, y, hits) {
        this.x = x;
        this.y = y;
        this.initialY = y;
        this.radius = BLOCK_RADIUS;
        this.hitsLeft = hits;
        this.isAlive = true;
    }

    hit() {
        if (this.hitsLeft === -1) {
            this.isAlive = false;
            ballCount++;
        } else if (this.hitsLeft > 0) {
            this.hitsLeft--;
            if (this.hitsLeft <= 0) {
                this.isAlive = false;
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(this.x, this.y, '#E74C3C'));
                }
            }
        }
    }

    draw() {
        if (!this.isAlive) return;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.hitsLeft === -1 ? '#dbef21' : '#E74C3C';
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Poppins';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (this.hitsLeft > 0) ctx.fillText(this.hitsLeft, this.x, this.y);
    }

    moveDown() {
        this.y += BLOCK_ROW_TOTAL_HEIGHT;
        this.initialY = this.y;
    }
}

/* =====================
   Game Logic
   ===================== */

function spawnNewRow() {
    numberedBlocks.forEach(b => b.moveDown());

    const spacing = canvas.width / (BLOCKS_PER_ROW + 1);
    for (let i = 0; i < BLOCKS_PER_ROW; i++) {
        if (Math.random() < 0.6) {
            numberedBlocks.push(
                new Block(
                    spacing * (i + 1),
                    BLOCK_RADIUS + 10,
                    Math.max(1, currentLevel)
                )
            );
        }
    }
    currentLevel++;
}

function shoot(e) {
    if (isShooting) return;
    isShooting = true;

    const rect = canvas.getBoundingClientRect();
    const dx = e.clientX - rect.left - currentBaseX;
    const dy = e.clientY - rect.top - currentBaseY;
    const len = Math.hypot(dx, dy);
    if (len === 0) return;

    const vx = (dx / len) * SHOOT_SPEED;
    const vy = (dy / len) * SHOOT_SPEED;

    ballsLaunched = 0;
    projectiles = [];

    function launch() {
        if (ballsLaunched >= ballCount) return;
        projectiles.push(new Projectile(currentBaseX, launchY, vx, vy));
        ballsLaunched++;
        setTimeout(launch, 60);
    }
    launch();
}

canvas.addEventListener('click', shoot);

/* =====================
   Loop
   ===================== */

function update() {
    projectiles.forEach(p => p.update());
    projectiles = projectiles.filter(p => !p.isFinished);

    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);

    if (isShooting && projectiles.length === 0) {
        isShooting = false;
        currentBaseX = landingX;
        firstBallLanded = false;
        spawnNewRow();
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    numberedBlocks.forEach(b => b.draw());
    projectiles.forEach(p => p.draw());
    particles.forEach(p => p.draw());

    ctx.beginPath();
    ctx.arc(currentBaseX, currentBaseY, 15, 0, Math.PI * 2);
    ctx.fillStyle = 'red';
    ctx.fill();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

/* =====================
   Init
   ===================== */

spawnNewRow();
spawnNewRow();
gameLoop();
</script>

</body>
</html>
